/**
 * using webdriver.io
 */
/**
 readme_nvm_vite_node_vue_2024.md
 pnpm add -D vitest
 pnpm add lodash -D
 */
import { describe, test,vi,beforeAll,afterAll,beforeEach,afterEach} from 'vitest';
import { expect,assert} from 'vitest';

/**
 * Should put this somewhere safe
 * todo filepath needs to be initialized as well...
 * @param fileName .json
 * @param data will automatically be changed
 */
import fs from 'node:fs';
export function writeToFile(fileName,data,space=2){
  const sFileName = /\./.test(fileName) ? fileName : fileName + '.json';
  const filePath = `tmp/${sFileName}`
  fs.writeFileSync(filePath,
    typeof data === 'string' ? data :JSON.stringify(data,null,+space)
  );
}
import { remote } from 'webdriverio';
/**
 * https://www.npmjs.com/package/webdriver#example
 */

/**
 * todo move me
 */
/* generated by gpt... not fully sure if it's actually working and or good*/
/**
 *
 * @param bearMean
 * @param bearStd
 * @param bullMean
 * @param bullStd
 * @param noChangeMean
 * @param noChangeStd
 * @param bearPct
 * @param bullPct
 * @param noChangePct
 * @return {{change: number, type: string}}
 * Change is percentage. so needs to be divide by 100 again
 */
export function randomPriceChange({
                                    bearMean = -0.03, bearStd = 0.05,
                                    bullMean = 0.03, bullStd = 0.05,
                                    noChangeMean = 0, noChangeStd = 0.05,
                                    bearPct = 33, bullPct = 33, noChangePct = 34
                                  } = {}) {
  // const r = Math.random() * 100;
  //first just to see if it's bear or bull
  const r = Math.random() * 100;
  let mean, std, type;
  if (r < bearPct) {
    [mean, std, type] = [bearMean, bearStd, 'bear'];
  } else if (r < bearPct + bullPct) {
    [mean, std, type] = [bullMean, bullStd, 'bull'];
  } else {
    [mean, std, type] = [noChangeMean, noChangeStd, 'no change'];
  }
  //2.
  // Box-Muller normal distribution
  const u = Math.random(), v = Math.random();
  const change = mean + std * Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
  return { type, change }; // change in percent
}
/**
 * todo move me
 * Wrapper Class
 * https://webdriver.io/docs/api/webdriver/
 */
export class WBMVotingDemo {
  /**
   *
   * @param browser {import('webdriverio').Browser}
   */
  constructor(browser) {
    this.browser = browser;
  }
  sChartSelector = '#mvbpPageLayout2025-real-default > div.px-0.mx-0.py-0.mx-0.col.col-12'
  /**
   * Step A. Passes if doesn't timeout
   * Step 0
   */
  async waitingForPage_s0(){
    const browser = this.browser;
    await browser.url('https://webetmarkets.com/app');
    const query =
      '#vMain > div > div > div:nth-child(1) > div > div > div > div.v-snack__action > button > span';
    await browser.$(query)
      .waitForExist({ timeout: 5000 })
    ;
    await browser.$(query).click();


  }

  /**
   * Step B. Check/Get Graph Element Dimensions
   * Step 1.
   * Assuming it's loaded
   * @returns {Promise<{x: number, y: number, width: number, height: number}>}
   */
  async getGraphElementDimensions_s1(){
    const browser = this.browser;


    const sChartSelector = this.sChartSelector;
    // const graphElement = await browser.$(sChartSelector).getElement();
    //i think this can be simplified
    const graphElement = await browser.$(sChartSelector);
    console.log(graphElement.selector);
    this.graphElement = graphElement;
    const {x,y} = await graphElement.getLocation();
    const {width,height} = await graphElement.getSize();
    const rect = { x, y, width, height };
    //log dimensions
    // const rect = await browser.getElementRect(graphElement.getElement().elementId);
    // const ryect = await graphElement.get
    console.log('Graph Element Dimensions:', rect);
    this.rect = rect;//maybe should do _rect and make it auto
    return rect;
  }
  //Just Clicking for now
  /**
   *
   * @param x {Number} offset from element's top-left corner
   * @param y {Number} offset from element's top-left corner
   * @param element {import('webdriverio').Element} optional
   * @return {Promise<void>}
   */
  async clickOnElement(x=0,y=0,element){
    const browser = this.browser;
    const el = element || await browser.$('body');//can be better wrapper
    await el.moveTo(); // moves mouse to center of the element
    // looks more simple than this generated one but this works
    // https://webdriver.io/docs/api/element/click/
    await browser.performActions([{
      type: 'pointer',
      id: 'mouse1',
      parameters: { pointerType: 'mouse' },
      actions: [
        // offset from element's top-left corner
        // { type: 'pointerMove', origin: el, x: 20, y: 30 },
        { type: 'pointerMove', origin: el, x, y },
        { type: 'pointerDown', button: 0 },//left click
        { type: 'pointerUp', button: 0 }//left click
      ]
    }]);
    await browser.releaseActions();
  }

  /**
   * Modified from puppeteer example in wbm-mvpb
   * @return {Promise<void>}
   */
  async voteRNG_s2(){
    const browser = this.browser;
    const { x, y, width, height } = this.rect;


    /** new dimensions are
     *  { x: 0, y: 60, width: 761, height: 321 }
     * */
    /* from 75% to 100% horizontally x ----> */
    const ele = this.graphElement;
    for (let i = 75; i <= 100; i++) {
    //maybe need to zoom in a bit for more finese?
    // for (let i = 75; i <= 75; i++) {
      const {change,type}= randomPriceChange()
      //slightly different because it's from the center
      // const xOffset = x + width * i / 100;//i think this is absolute. so now it's half i think
      let xOffset,yOffset;
      xOffset = (width * i / 100) - width/2;//i think this is absolute. so now it's half i think
      yOffset = (height/2 * (change));//change is slightly different

      xOffset = Math.floor(xOffset);
      yOffset = Math.floor(yOffset);
      //bear bull not exact but let's see? because it's not right in middle, which i feel is ok
      console.log(`Clicking at: x=${xOffset}, y=${yOffset}, change=${change} ${type}`);
      // https://stackoverflow.com/questions/41805494/convert-xy-reference-to-pixel-reference
      // await ele.moveTo({
      //   xOffset,
      //   yOffset,
      //   // xOffset: 100,//+ goes right, - goes left
      //   // yOffset: 100,//+ goes down, - goes up
      // });//center
      await ele.click({
        x: xOffset,
        y: yOffset
      });
      // await ele.click({
      //     x:x,
      //     y:y
      //   }
      // );//clicking random

      // await page.mouse.click(x + width * i/100, y + (height * (0.5 + change)));//clicking random. og old
      // to simulate delay... maybe better way
      // await browser.saveScreenshot('tmp/wbm-mousemove-vote-prod-0.png');
      await new Promise(resolve => setTimeout(resolve, 300));//todo fix me?


      //not sure if this is needed atm... tbh
      // {
      // const midX = width / 2;
      // const midY = height / 2;
      // await page.mouse.click(x + width * i/100, y + midY);//clicking in the middle of the graph
      // }
    }
  }
}


/**
 * https://webdriver.io/docs/seleniumgrid/
 * "webSocketUrl": "ws://172.17.0.2:4444/session/e32fdcf15489792d5b39edd2bd7e5dd9/se/bidi",
 * https://www.gridlastic.com/webdriverio.html
 *
 *
 * Using Docker to run hub and single chrome node
 * might add dockercompose / dockerfile to this project later
 * standalone is meant for local dev only
 *
 * Expects Docker as well
 */
describe('wbm-voting_webdriverio', function(){
  /** @type {import('webdriverio').Browser} */
  let browser0,browser1;//maybe array better?
  let browsers,browser;//

  /** local docker webdriverio params */
  const params = {
    protocol: 'http',
    hostname: 'host.docker.internal', // or your Docker host IP
    port: 4444,
    acceptInsecureCerts: true,
    path: '/wd/hub',
    logLevel:'warn',//default is info
    // logLevel:'error',//default is info
    capabilities: {
      browserName: 'chrome',
      'goog:chromeOptions': {args: ['--headless', '--disable-gpu']}
      // 'goog:chromeOptions': { args: ['headless', 'disable-gpu'] }
      //http://host.docker.internal:7900/
      //http://host.docker.internal:7901/
      //http://host.docker.internal:4444/ui/#
    }
  }
  beforeEach(async function(){
    // console.log('beforeEach');
    browser = await remote(params);
    // browsers = [browser0,browser1];
  });
  afterEach(async function(){
    // console.log('afterEach');
    if (browser) {
      await browser.deleteSession();
      browser = null;
    }
  });
  /** currently headless and expects docker */
  test('webetmarkets.com/app smoke test', async function(){
    const wbmVotingDemo = new WBMVotingDemo(browser);
    await wbmVotingDemo.waitingForPage_s0();
    //maybe want to check for title for something more concrete?
  });

  /**
   *
   * maybe take screenshot?
   */
  test('wbm check window size', async function(){
    const wbmVotingDemo = new WBMVotingDemo(browser);
    await wbmVotingDemo.waitingForPage_s0();
    await wbmVotingDemo.getGraphElementDimensions_s1();

    // Graph Element Dimensions: { x: 0, y: 60, width: 761, height: 321 }
    // wonder if it'as always the same
    //debug
    await browser.saveScreenshot('tmp/wbm-check-window-size.png');

  });
  test('wbm mousemove middle', async function(){
    const wbmVotingDemo = new WBMVotingDemo(browser);
    await wbmVotingDemo.waitingForPage_s0();

    await wbmVotingDemo.clickOnElement()
    await browser.saveScreenshot('tmp/wbm-mousemove-middle-0.png');

  });
  test('wbm mousemove vote prod', async function(){
    const wbmVotingDemo = new WBMVotingDemo(browser);
    await wbmVotingDemo.waitingForPage_s0();
    await wbmVotingDemo.getGraphElementDimensions_s1();
    await wbmVotingDemo.voteRNG_s2();

    await browser.saveScreenshot('tmp/wbm-mousemove-vote-prod-0.png');
    /** debug notes: graph dimension
     *  { x: 0, y: 60, width: 761, height: 321 }
     *
     *  x=570.75, y=229.8069482597095, change=0.028993608285699336
     *   x=761, y=211.4770111844872, change=-0.028108999425273493
     */

  });
  /**
   * Expects at least two sessions
   */
  test.skip('webetmarkets.com chrome_1', async function(){
    //https://webdriver.io/docs/api/webdriverBidi/
    //https://webdriver.io/docs/api/modules#remoteoptions-modifier
    //hmm different configs
    // https://www.npmjs.com/package/webdriverio

    browser0 = await remote(params);
    browser1 = await remote(params);
    await browser0.url('http://example.com');
    const text0 = await browser0.$('h1').getText();

    await browser1.url('http://example.com');
    const text1 = await browser1.$('h1').getText();

    await browser0.deleteSession();
    await browser1.deleteSession();
    expect(text0).toBe('Example Domain');
    expect(text1).toBe('Example Domain');
  });

  /** clean up? timing can be tricky*/
  // afterAll(() => {
  //   if (browser0) {
  //     browser0.deleteSession();
  //   }
  //   if (browser1) {
  //     browser1.deleteSession();
  //   }
  // });

},100000);

/**
 * just prints to console
 */
test('randomPriceChange',function(){
  // let actual = randomPriceChange()
  // console.log(actual);
  // for (let i = 0; i < 100; i++) {
  // for (let i = 0; i < 26; i++) {
  for (let i = 0; i < 2; i++) {
    const actual = randomPriceChange()
    console.log(actual);
    const {type,change} = actual;
    console.log(0.5 + change);//can assert / fix later


  }
})
